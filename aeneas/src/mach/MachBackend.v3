// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A machine-independent representation of an instruction.
class MachInstr(name: string) {
	var live: bool;		// used for marking dead code
	var useStart: int;	// index into code describing use/def info
	var useEnd: int;	// end index into code describing use/def info
	var moves: MachMoves;	// moves to be inserted before instruction

	def render(buf: StringBuilder) -> StringBuilder;
	def emit();
}
// Moves inserted before/after an instruction, either due to SSA deconstruction,
// spilling, register moves, calling conventions, etc
class MachMoves {
	var before: MoveResolver;	// phys -> phys moves, before
	var varMoves: List<(int, int)>; // usepos -> defpos moves, before
	var valMoves: List<(Val, int)>; // value -> usepos moves, before
	var after: MoveResolver;	// phys -> phys moves, after
}
// Machine-independent representation of virtual register classes
enum RegClass {
	REF,
	I32,
	I64,
	F32,
	F64
}
// Conversion functions from V3 Types to RegClasses
component RegClasses {
	def fromType(t: Type) -> RegClass {
		match (t.typeCon.kind) {
			V3Kind.INT => return fromIntType(IntType.!(t));
			V3Kind.FLOAT => {
				var ftc = Float_TypeCon.!(t.typeCon);
				return if(ftc.is64, RegClass.F64, RegClass.F32);
			}
			V3Kind.ENUM => return fromIntType(V3.getVariantTagType(t));
			V3Kind.ENUM_SET => return fromIntType(V3.getEnumSetType(t));
			_ => return RegClass.REF;
		}
	}
	def fromIntType(t: IntType) -> RegClass {
		return if(t.width <= 32, RegClass.I32, RegClass.I64);
	}
}
enum Usage { NONE, ONCE, MULTIPLE }
// Machine-independent representation of a virtual register.
class VReg {
	// -- state for code gen --------------------------------
	def ssa: SsaInstr;		// corresponding ssa instruction (if any)
	def varNum: int;		// virtual register number
	def varSize: int;		// number of virtual registers this var represents
	var start: int = -1;		// start position of code that defines this var
	var end: int = -1;		// end position of code that defines this var
	var live: bool;			// true if live
	// -- state for register allocation ---------------------
	var hint: byte;			// physical register hint
	var regClass: RegClass;		// required register type
	var reg: byte;			// assigned physical register
	var block: SsaBlock;
	var prev: VReg;			// prev link for list management
	var next: VReg;			// next link for list management
	var spill: int;			// assigned spill slot (< 0 indicates a constant)
	var endPos: int;		// last live position
	// -- state for stackifier -----------------------------
	var usage = Usage.NONE;
	var consumedFromStack: bool;
	var parmoveState: int;
	var stackIndex = -2;

	new(ssa, varNum, varSize, isConst: bool) {
		if (isConst) spill = -2 - varNum; // constants have invalid spill slots
	}
	def loc() -> int {
		return if(reg != 0, reg, spill);
	}
	def isConst() -> bool {
		return spill < 0;
	}
}
// Representation of a machine frame, including spill slots and space for outgoing params
class MachFrame(conv: MachCallConv, wordSize: int) {
	var spillVars: int;		// spilled variables
	var spillArgs: int;		// space for outgoing spilled arguments
	var frameSize: int = -1;	// architecture-specific total frame size
	var tmpSpill: int = -1;		// temporary spill slot
	def IS_64: int = 0x40000000;	// if the spilled value is 64 bits

	def allocSpill(regClass: RegClass) -> int {
		match (regClass) {
			I64, F64 => {
				var numSpill = 64 / wordSize;
				if (numSpill == 0) numSpill = 1; // in case word size is larger than 64-bit XXX: is it required?
				var spill = conv.regSet.spillStart + spillVars;
				spillVars += numSpill;
				return spill | IS_64;
			}
			_ => return conv.regSet.spillStart + spillVars++;
		}
	}
	def getTmpSpill(regClass: RegClass) -> int {
		var is64 = if(regClass == RegClass.I64 || regClass == RegClass.F64, IS_64);
		if (tmpSpill < 0) {
			tmpSpill = conv.regSet.spillStart + spillVars;
			spillVars += 2; // always use two slots
		}
		return tmpSpill | is64;
	}
	def allocCallerSpace(conv: MachCallConv) -> MachCallConv {
		allocOverflow(conv.overflow);
		return conv;
	}
	def allocOverflow(overflow: int) {
		if (overflow > spillArgs) spillArgs = overflow;
	}
	def slots() -> int {
		return spillVars + spillArgs;
	}
	def size() -> int {
		return if(frameSize >= 0, frameSize, V3.fail("frame size not set"));
	}
	def is64(loc: int) -> bool {
		return (loc & IS_64) != 0;
	}
	def un64(loc: int) -> int {
		return loc & ~IS_64;
	}
}
// Defines physical locations (registers, register sets, and stack locations).
// 1. 0 means an unassigned location.
// 2. Physical registers have low numbers in the range [1 ... physregs].
// 3. Sets of registers have numbers in the range (physregs ... spillStart).
// 4. Spill locations have numbers [spillStart ... callerStart).
// 5. Caller locations have numbers [callerStart ... calleeStart).
// 6. Callee locations have numbers [calleeStart ... MAX_INT).
class MachRegSet {
	def physRegs: int;			// number of physical registers
	def regSets: Array<Array<byte>>;	// registers in each set
	def names: Array<string>;		// names of each register and set
	def regClasses: Array<byte>;		// registers in each class
	def scratch: int;
	def fpScratch: int;
	def spillStart: int = regSets.length;
	def callerStart: int;
	def calleeStart: int;
	def matrix = BitMatrix.new(physRegs + 1, regSets.length);
	def IS_64: int = 0x40000000;
	new(physRegs, regSets, names, regClasses, scratch, fpScratch, callerStart, calleeStart) {
		// compute the matrix of physical register / register set membership
		for (i < regSets.length) {
			var rs = regSets[i];
			if (rs == null) continue;
			for (r in rs) matrix[r, i] = true;
		}
	}
	def isInRegSet(loc: int, snum: int) -> bool {
		if (loc < 1 || loc >= regSets.length) return false;
		return matrix[loc, snum];
	}
	def isReg(loc: int) -> bool {
		return loc > 0 && loc <= physRegs;
	}
	def isRegSet(loc: int) -> bool {
		return loc > 0 && loc <= regSets.length;
	}
	def isStack(loc: int) -> bool {
		return loc >= spillStart;
	}
	def isCallerStack(loc: int) -> bool {
		loc &= ~(IS_64);
		return loc >= callerStart && loc < calleeStart;
	}
	def isMultiple(loc: int) -> bool {
		if (loc == 0) return true;
		if (loc <= physRegs) return false;
		return loc < spillStart;
	}
	def getRegSet(rcl: RegClass) -> int {
		var rclass = (rcl.tag + 1) >>> 2; // XXX: use one array per register class
		return regClasses[rclass];
	}
	def identify(loc: int) -> string {
		loc &= ~(IS_64);
		if (loc < 0) return Strings.format1("invalid#%d", loc);
		if (loc == 0) return "unassigned";
		if (loc < spillStart) {
			var name = names[loc];
			if (name != null) return name;
			if (loc <= physRegs) return Strings.format1("r#%d", loc);
			else return Strings.format1("set#%d", loc);
		}
		if (loc < callerStart) return Strings.format1("spill#%d", loc - spillStart);
		if (loc < calleeStart) return Strings.format1("caller#%d", loc - callerStart);
		return Strings.format1("callee#%d", loc - calleeStart);
	}
}
// Machine-independent representation of the calling convention for a specific call.
class MachCallConv {
	def regSet: MachRegSet;		// associated register set
	def paramTypes: Array<Type>;	// parameter types
	def paramLocs: Array<int>;	// locations of parameters
	def returnTypes: Array<Type>;	// return types
	def retLocs: Array<int>;	// locations of return value(s)
	def overflow: int;		// number of overflow stack arguments
	new(regSet, paramTypes, paramLocs, returnTypes, retLocs, overflow) { }
	def callerParam(i: int) -> int {
		return adjust(paramLocs[i], regSet.callerStart);
	}
	def callerRet(i: int) -> int {
		return adjust(retLocs[i], regSet.callerStart);
	}
	def calleeParam(i: int) -> int {
		return adjust(paramLocs[i], regSet.calleeStart);
	}
	def calleeRet(i: int) -> int {
		return adjust(retLocs[i], regSet.calleeStart);
	}
	private def adjust(loc: int, adjust: int) -> int {
		if (loc <= regSet.physRegs) return loc;
		return loc - regSet.spillStart + adjust;
	}
}

type Operand {
	case Scratch;
	case Immediate(val: Val);
	case Use(vreg: VReg, constraint: int);
	case Def(vreg: VReg, constraint: int);
	case Kill(livepoint: int, constraint: int);
	case Overwrite(dst: VReg, src: VReg, constraint: int);
	case Label(block: SsaBlock, label: Label);
	case ExSource(ex: string, source: Source);

	def isImm() -> bool { return tag == 1; }
}

class ArchInstr(op: int, operands: Array<Operand>) {
	var prev: ArchInstr;
	var next: ArchInstr;
	def opcode() -> i28 { return i28.view(op); }
	def remove() {
		if (prev != null) prev.next = next;
		if (next != null) next.prev = prev;
		prev = next = null;
	}
}

// Constants for Arch instructions.
component ArchInstrs {
	// flags for all arch instructions reordering and register allocation
	def FLAG_NO_GAP = 0x80000000;	// cannot insert instructions before this instruction
	def FLAG_REMAT	= 0x40000000;	// instruction can be copied for rematerialization
	def FLAG_LOAD	= 0x20000000;	// instruction reads mutable state
	def FLAG_STORE	= 0x10000000;	// instruction writes mutable state

	def NUM_FLAGS: u5 = 4;

	// block and SSA resolution instructions
	def ARCH_NOP	 = -6;
	def ARCH_BLOCK	 = -5;
	def ARCH_ENTRY	 = -4;
	def ARCH_PARMOVE = -3;
	def ARCH_END	 = -2;
	def ARCH_RET	 = -1;

	def NO_OPERANDS: Array<Operand> = [];
}

def CACHED_INT_IMMEDIATES = [
	Operand.Immediate(Box<int>.new(-1)),
	Operand.Immediate(Box<int>.new(0)),
	Operand.Immediate(Box<int>.new(1)),
	Operand.Immediate(Box<int>.new(2)),
	Operand.Immediate(Box<int>.new(3)),
	Operand.Immediate(Box<int>.new(4)),
	Operand.Immediate(Box<int>.new(5)),
	Operand.Immediate(Box<int>.new(6)),
	Operand.Immediate(Box<int>.new(7)),
	Operand.Immediate(Box<int>.new(8))
];

// Basic algorithm for code generation.
class SsaMachGen(context: SsaContext, mach: MachProgram, regSet: MachRegSet, w: MachDataWriter) {
	def operands = Vector<Operand>.new();
	def vars = Vector<VReg>.new();
	var lowestMark: int;
	var blocks: SsaBlockOrder;
	var order: Vector<SsaBlockInfo>;
	var liveness: BitMatrix;
	var numLivepoints = 0;
	def livepoints = Vector<(SsaBlock, ArchInstr, Operand.Kill)>.new();
	var first: ArchInstr;
	var cursor: ArchInstr;
	var blockEnd: ArchInstr;
	var frame: MachFrame;
	var curBlock: SsaBlock;
	var computingLiveness: bool;
	var out: ArchInstrBuffer;

	def reset(graph: SsaGraph, blocks: SsaBlockOrder, frame: MachFrame) {
		this.operands.length = 0;
		this.vars.length = 0;
		this.context.graph = graph;
		this.context.block = null;
		this.lowestMark = graph.markGen++;
		this.blocks = blocks;
		this.order = if(blocks != null, blocks.order);
		this.liveness = BitMatrix.new(if(order != null, order.length, 1), 32); // XXX: reuse?
		this.numLivepoints = 0;
		this.livepoints.length = 0;
		this.first = null;
		this.cursor = null;
		this.frame = frame;
		this.curBlock = null;
		this.computingLiveness = true;
	}
	def generate(m: IrMethod, frame: MachFrame) {
		context.enterMethod(m);
		var blocks = SsaBlockOrder.new(m.ssa);
		reset(m.ssa, blocks, frame);
		selectInstructionsForGraph();
		print();
	}
	def print() {
		if (!context.shouldPrintMach()) return;
		// print header
		var out = getOutput();
		out.puts("Arch instructions for: ");
		var render: StringBuilder -> StringBuilder;
		if (context.spec != null) context.spec.render(out);
		else if (context.method != null) context.method.renderLong(out);
		out.outln();
		// print instructions
		var indent = 1;
		for (i = first; i != null; i = i.next) {
			indent = out.putInstr(indent, i);
		}
		out.outln();
	}
	def selectInstructionsForGraph() {
		cursor = ArchInstr.new(ArchInstrs.ARCH_END, []);
		// Process blocks in reverse order.
		for (i = order.length - 1; i >= 0; i--) {
			var info = order[i], block = info.block;
			context.block = block;
			gatherLivenessForBlock(block);
			selectInstructionsForBlock(block);
			if (info.loop != null) finishLoopLiveness(info);
		}
		// emit the entry instruction.
		visitEntry(context.graph.params);
		first = cursor;
		cursor = null;
	}
	def finishLoopLiveness(info: SsaBlockInfo) {
		// Propagate liveness from the loop header to all live points
		// contained in the loop.
		var end = info.loop.end;
		for (i = livepoints.length - 1; i >= 0; i--) {	// process newest first
			var t = livepoints[i], block = t.0;
			if (block.mark > end) break;  // rely on backwards codegen order
			liveness.or(order.length + t.2.livepoint, block.mark);
		}
	}
	def gatherLivenessForBlock(block: SsaBlock) {
		for (e in block.succs()) {
			var succ = e.dest;
			// union the succesor's live-in set into this.
			liveness.or(block.mark, succ.mark);
		}
	}
	def selectInstructionsForBlock(block: SsaBlock) {
		curBlock = block;
		blockEnd = cursor;
		// Pre-process instructions in forward order.
		// Mark instructions in this block.
		for (i = block.next; i != block; i = i.next) {
			if (!SsaInstr.?(i)) break;
			var instr = SsaInstr.!(i);
			var vreg = getVReg(instr);
			vreg.block = block;
		}
		// Select instructions in reverse order.
		for (i = block.prev; i != block; i = i.prev) {
			// Skip instructions that are not live.
			if (SsaPhi.?(i)) break;
			if (!isLive(i, block) && i.facts.O_PURE) continue;
			selectInstructions(block, i);
			advanceCursor();
		}
		// Cap the top of the block with a special instruction.
		emit1(ArchInstrs.ARCH_BLOCK, useLabel(block));
		advanceCursor();
	}
	def advanceCursor() {
		while (cursor.prev != null) cursor = cursor.prev;
	}
	def selectInstructions(block: SsaBlock, i: SsaLink) {
		// Dispatch to appropriate architecture-specific routine.
		match (i) {
			x: SsaApplyOp => visitApply(block, x);
			x: SsaGoto => {
				// Emit SSA-resolution moves for the successor if necessary.
				emitPhiResolutionMoves(block, x.succs[0]);
				visitGoto(block, x);
			}
			x: SsaIf => visitIf(block, x);
			x: SsaReturn => visitReturn(block, x);
			x: SsaSwitch => visitSwitch(block, x);
			x: SsaThrow => visitThrow(block, x);
			_ => context.fail("invalid instruction type");
		}
	}
	def emitPhiResolutionMoves(block: SsaBlock, edge: SsaCfEdge) {
		var index = edge.desti;
		// Add definitions of all phis.
		for (i = edge.dest.next; SsaPhi.?(i); i = i.next) {
			var phi = SsaPhi.!(i);
			dfn(phi);
		}
		// Add uses of all phi inputs.
		for (i = edge.dest.next; SsaPhi.?(i); i = i.next) {
			var phi = SsaPhi.!(i);
			use(phi.inputs[index].dest);
		}
		emitN(ArchInstrs.ARCH_PARMOVE);
	}
	// Mark {i} as live in {block}
	def setLive(i: SsaInstr, block: SsaBlock) {
		liveness[block.mark, getVReg(i).varNum] = true;
	}
	// Check if {i} is live in {block}
	def isLive(i: SsaLink, block: SsaBlock) -> bool {
		if (i.mark >= context.graph.markGen) {
			context.fail1("mark @%d invalid", i.uid);
			return false;
		}
		if (i.mark <= lowestMark) return false;
		return liveness[block.mark, i.mark - lowestMark];
	}

	def getVReg(i: SsaInstr) -> VReg {
		// TODO: handle multiple return values
		if (i.mark >= context.graph.markGen) {
			context.fail1("mark @%d invalid", i.uid);
			return null;
		}
		if (i.mark <= lowestMark) {
			return newVReg(i);
		}
		return vars[i.mark - lowestMark];
	}
	def newVReg(i: SsaInstr) -> VReg {
		var next = context.graph.markGen++;
		var width = 1, rcl: RegClass;
		if (i != null) {
			width = numVars(i);
			i.mark = next;
			rcl = RegClasses.fromType(i.getType());
		}
		var id = next - lowestMark;
		var length = id + width + 1;
		liveness.widen(length);
		vars.grow(length);
		vars.length = length;
		var n = VReg.new(i, id, width, SsaConst.?(i));
		n.regClass = rcl;
		vars[id] = n;
		return n;
	}
	def newLivepoint() -> int {
		return numLivepoints++;
	}
	def numVars(i: SsaInstr) -> int {
		return Tuple.length(i.getType());
	}
	def updateLiveness(i: ArchInstr) {
		def DEFS = 0, KILLS = 1, OVW = 2, USES = 3;
		var state = DEFS;
		var row = if(context.block != null, context.block.mark);
		for (o in i.operands) match (o) {
			Def(vreg, constraint) => {
				if (state > DEFS) context.fail("out of order def");
				liveness[row, vreg.varNum] = false;
				state = DEFS;
			}
			Overwrite(dst, use, constraint) => {
				if (state > OVW) context.fail("out of order ovw");
				liveness[row, dst.varNum] = false;
				liveness[row, use.varNum] = true;
				state = OVW;
			}
			Kill(livepoint, constraint) => {
				if (state > KILLS) context.fail("out of order kill");
				if (livepoint >= 0) {
					var index = order.length + livepoint;
					liveness.grow(index + 1);
					liveness.or(index, row);
					livepoints.put((context.block, i, Operand.Kill.!(o)));
				}
				state = KILLS;
			}
			Use(vreg, constraint) => {
				liveness[row, vreg.varNum] = true;
				state = USES;
			}
			_ => ;
		}
	}
	def isRef(v: VReg) -> bool {
		if (v == null || v.ssa == null) return false;
		if (SsaConst.?(v.ssa)) return false;
		return mach.isRefType(v.ssa.getType());
	}
	def runInsertion<T>(f: T -> void, arg: T, next: ArchInstr) {
		var prevCursor = cursor, prevL = computingLiveness;
		computingLiveness = false;
		cursor = next;
		f(arg);
		computingLiveness = prevL;
		cursor = prevCursor;
	}
	// Reorganizes a parallel move of (dest1, dest2..., src1, src2) operands into
	// a vector of (src, destination list) pairs.
	// XXX: reorganize parallel moves to make this unnecessary?
	def gatherParallelMoveDests(i: ArchInstr, dests: Vector<(VReg, List<Operand.Def>)>) {
		dests.length = 0;
		var operands = i.operands;
                var max = operands.length / 2;
		for (i < max) {
			var d = Operand.Def.!(operands[i]), u = Operand.Use.!(operands[i + max]);
			var v = u.vreg;
			if (v.parmoveState <= 0) {
				var index = dests.length;
				v.parmoveState = 1 + index;
				dests.put(v, List.new(d, null));
			} else {
				var index = v.parmoveState - 1;
				var prev = dests[index].1;
				dests[index] = (v, List.new(d, prev));
			}
		}
	}
	//======================================================================
	// MachStackifier uses these codegen methods to insert loads, stores,
	// etc. Only relevant targets implement the gen*() methods.
	//======================================================================
	def insertLoadLocal(v: VReg, next: ArchInstr) {
		runInsertion(genLoadLocal, v, next);
	}
	def insertStoreLocal(v: VReg, pop: bool, next: ArchInstr) {
		runInsertion(genStoreLocal, (v, pop), next);
	}
	def insertPop(v: VReg, next: ArchInstr) {
		runInsertion(genPop, v, next);
	}
	def insertLoadConst(t: Type, val: Val, next: ArchInstr) {
		runInsertion(genLoadConst, (t, val), next);
	}
	def genLoadLocal(v: VReg);		// arch-specific
	def genStoreLocal(v: VReg, pop: bool);	// arch-specific
	def genPop(v: VReg);			// arch-specific
	def genLoadConst(t: Type, val: Val);	// arch-specific

	//======================================================================
	// ShadowStackSpiller uses these codegen methods to insert saves,
	// restores, etc. Only relevant targets implement the gen*() methods.
	//======================================================================
	def insertShadowStackAlloc(shadow_sp: VReg, slots: int, next: ArchInstr) {
		runInsertion(genShadowStackAlloc, (shadow_sp, slots), next);
	}
	def insertShadowStackFree(shadow_sp: VReg, slots: int, next: ArchInstr) {
		runInsertion(genShadowStackFree, (shadow_sp, slots), next);
	}
	def insertShadowStackSave(shadow_sp: VReg, v: VReg, slot: int, next: ArchInstr) {
		runInsertion(genShadowStackSave, (shadow_sp, v, slot), next);
	}
	def insertShadowStackRestore(shadow_sp: VReg, v: VReg, slot: int, next: ArchInstr) {
		runInsertion(genShadowStackRestore, (shadow_sp, v, slot), next);
	}
	def newShadowSpTmp() -> VReg;					// arch-specific
	def genShadowStackAlloc(shadow_sp: VReg, slots: int);		// arch-specific
	def genShadowStackFree(shadow_sp: VReg, slots: int);		// arch-specific
	def genShadowStackSave(shadow_sp: VReg, v: VReg, slot: int);	// arch-specific
	def genShadowStackRestore(shadow_sp: VReg, v: VReg, slot: int);	// arch-specific

	//======================================================================
	// SimpleRegAlloc uses these codegen methods to insert saves and restore
	// of vregs from registers
	//======================================================================
	def insertSaveLocal(reg: int, v: VReg, next: ArchInstr) {
		runInsertion(genSaveLocal, (reg, v), next);
	}
	def insertRestoreLocal(v: VReg, reg: int, next: ArchInstr) {
		runInsertion(genRestoreLocal, (v, reg), next);
	}
	def genSaveLocal(reg: int, v: VReg);
	def genRestoreLocal(v: VReg, reg: int);

	//======================================================================
	// Helper routines for emitting instructions.
	//======================================================================
	def matchAddImm(i: SsaInstr, disp: Val) -> (SsaInstr, Val) {
		// TODO: check covering condition: in same block and single use
		if (!SsaApplyOp.?(i)) return (i, disp);
		var apply = SsaApplyOp.!(i);
		if (Opcode.IntAdd.?(apply.op.opcode) || Opcode.PtrAdd.?(apply.op.opcode)) {
			var x = apply.input0(), y = apply.input1();
			if (SsaConst.?(x)) {
				var disp2 = tryAddConsts(disp, SsaConst.!(x).val);
				if (disp2 != null) return matchAddImm(y, disp2);
			}
			if (SsaConst.?(y)) {
				var disp2 = tryAddConsts(disp, SsaConst.!(y).val);
				if (disp2 != null) return matchAddImm(x, disp2);
			}
		}
		return (i, disp);
	}
	def tryAddConsts(k1: Val, k2: Val) -> Val {
		if (k1 == null) return k2;
		if (k2 == null) return k1;
		match (k1) {
			x: Box<int> => match (k2) {
				y: Box<int> => return Box<int>.new(x.val + y.val);
				y: Addr => return y.add(x.val);
			}
			x: Addr => match (k2) {
				y: Box<int> => return x.add(y.val);
			}
		}
		return null;
	}
	def canCover(i: SsaInstr) -> bool {
		if (!inSameBlock(i)) return false;
		if (i.useList.next != null) return false;
		return true;
	}
	def cover(optag: u8, i: SsaInstr) -> SsaApplyOp {
		if (!SsaApplyOp.?(i)) return null;
		if (!inSameBlock(i)) return null;
		var apply = SsaApplyOp.!(i);
		if (apply.op.opcode.tag != optag) return null;
		return apply;
	}
	def emit0(opcode: int) {
		if (operands.length != 0) return context.fail("expected 0 operands");
		emitN(opcode);
	}
	def emit1(opcode: int, a: void) {
		if (operands.length != 1) return context.fail("expected 1 operand");
		emitN(opcode);
	}
	def emit2(opcode: int, a: void, b: void) {
		if (operands.length != 2) return context.fail("expected 2 operands");
		emitN(opcode);
	}
	def emit3(opcode: int, a: void, b: void, c: void) {
		if (operands.length != 3) return context.fail("expected 3 operands");
		emitN(opcode);
	}
	def emitN(opcode: int) {
		var x = operands.extract();
		var i = ArchInstr.new(opcode, x);
		// insert {i} between {cursor.prev} and {cursor}
		i.next = cursor;
		var prev = cursor.prev;
		if (prev != null) {
			prev.next = i;
			i.prev = prev;
		}
		cursor.prev = i;
		if (computingLiveness) updateLiveness(i);
	}
	def useLabel(block: SsaBlock) {
		operands.put(Operand.Label(block, order[block.mark].label));
	}
	def dfnAll(i: SsaInstr) {
		var rv = getVReg(i);
		match (rv.varSize) {
			0 => ;
			1 => dfn(i);
			_ => {
				var proj = Array<SsaInstr>.new(rv.varSize);
				for (l: Edge<SsaInstr> = i.useList; l != null; l = l.next) {
					var u = l.src;
					if (SsaApplyOp.?(u)) {
						match (SsaApplyOp.!(u).op.opcode) {
							TupleGetElem(index) => proj[index] = u;
							_ => ;
						}
					}
				}
				for (j < rv.varSize) {
					operands.put(Operand.Def(vars[rv.varNum + j], 0));
				}
			}
		}
	}
	def dfn(i: SsaInstr) {
		operands.put(Operand.Def(getVReg(i), 0));
	}
	def dfnv(vreg: VReg, constraint: int) {
		operands.put(Operand.Def(vreg, constraint));
	}
	def dfnv0(vreg: VReg) {
		operands.put(Operand.Def(vreg, 0));
	}
	def kill(livepoint: int, constraint: int) {
		operands.put(Operand.Kill(livepoint, constraint));
	}
	def useAll(array: Array<SsaDfEdge>, start: int) {
		for (j = start; j < array.length; j++) use(array[j].dest);
	}
	private def upref(vreg: VReg) -> VReg {
		if (vreg.isConst()) return vreg;
		if (vreg.usage == Usage.NONE) vreg.usage = Usage.ONCE;
		else vreg.usage = Usage.MULTIPLE;
		return vreg;
	}
	def use(i: SsaInstr) {
		operands.put(Operand.Use(upref(getVReg(i)), 0));
	}
	def usev(vreg: VReg, constraint: int) {
		operands.put(Operand.Use(upref(vreg), constraint));
	}
	def usev0(vreg: VReg) {
		operands.put(Operand.Use(upref(vreg), 0));
	}
	def op(op: Operand) {
		operands.put(op);
	}
	def useReg(i: SsaInstr) {
		var vreg = getVReg(i);
		operands.put(Operand.Use(upref(vreg), anyReg(vreg)));
	}
	def useImm(val: Val) {
		operands.put(Operand.Immediate(val));
	}
	def useInt(val: int) {
		var x = val + 1;
		if (x >= 0 && x < CACHED_INT_IMMEDIATES.length) {
			operands.put(CACHED_INT_IMMEDIATES[x]);
			return;
		}
		operands.put(Operand.Immediate(Int.box(val)));
	}
	def useIntConst(val: int) {
		use(context.graph.intConst(val));
	}
	def useAddrConst(addr: Addr) {
		use(context.graph.valConst(mach.data.ptrType, addr));
	}
	def useLongConst(val: int) {
		use(context.graph.valConst(Long.TYPE, Long.box(val)));
	}
	def useFixed(i: SsaInstr, constraint: int) {
		operands.put(Operand.Use(upref(getVReg(i)), constraint));
	}
	def dfnFixed(i: SsaInstr, constraint: int) {
		operands.put(Operand.Def(getVReg(i), constraint));
	}
	def dfnReg(i: SsaInstr) {
		var vreg = getVReg(i);
		operands.put(Operand.Def(vreg, anyReg(vreg)));
	}
	def ovwReg(d: SsaInstr, u: SsaInstr) {
		var dreg = getVReg(d);
		operands.put(Operand.Overwrite(dreg, upref(getVReg(u)), anyReg(dreg)));
	}
	def ovwv(d: VReg, u: VReg, constraint: int) {
		operands.put(Operand.Overwrite(d, upref(u), constraint));
	}
	def anyReg(vreg: VReg) -> int {
		return frame.conv.regSet.getRegSet(vreg.regClass);
	}
	def useScratch() {
		operands.put(Operand.Scratch);
	}
	def newTmp(t: Type) -> VReg {
		var vreg = newVReg(null);
		vreg.regClass = RegClasses.fromType(t);
		return vreg;
	}
	def id(i: SsaInstr, vreg: VReg) -> VReg {
		i.mark = vreg.varNum;
		return vreg;
	}
	def useExSource(ex: string, source: Source) {
		operands.put(Operand.ExSource(ex, source));
	}

	def toLabel(o: Operand) -> Label {
		match (o) {
			Label(block, label) => return label;
			_ => context.fail("expected label");
		}
		return null;
	}
	def toBlock(o: Operand) -> SsaBlock {
		match (o) {
			Label(block, label) => return block;
			_ => context.fail("expected block");
		}
		return null;
	}
	def toInt(o: Operand) -> int {
		return Int.unbox(toImm(o));
	}
	def toImm(o: Operand) -> Val {
		match (o) {
			Immediate(val) => return val;
			_ => context.fail("expected immediate");
		}
		return null;
	}
	def toVar(o: Operand) -> VReg {
		match (o) {
			Use(vreg, constraint) => return vreg;
			Def(vreg, constraint) => return vreg;
			_ => context.fail("expected immediate");
		}
		return null;
	}
	def toExSource(o: Operand) -> (string, Source) {
		match (o) {
			ExSource(ex, source) => return (ex, source);
			_ => context.fail("expected exception + source");
		}
		return (null, null);
	}
	def inSameBlock(i: SsaInstr) -> bool {
		if (order.length == 1) return true;
		return getVReg(i).block == curBlock;
	}
	def isSigned(op: Operator) -> bool {
		return IntType.!(op.typeArgs[0]).signed;
	}

	//======================================================================
	// Architecture-specific routines.
	//======================================================================

	// Instruction selection.
	def visitEntry(params: Array<SsaParam>) {
		for (i < params.length) {
			var p = params[i];
			if (!isLive(p, context.block)) continue;
			if (frame == null) dfn(p);
			else {
				var vreg = getVReg(p), loc = frame.conv.callerParam(i);
				dfnFixed(p, loc);
				if (frame.conv.regSet.isStack(loc)) vreg.spill = loc;
			}
		}
		emitN(ArchInstrs.ARCH_ENTRY);
		advanceCursor();
	}
	def visitApply(block: SsaBlock, i: SsaApplyOp);
	def visitThrow(block: SsaBlock, i: SsaThrow);
	def visitIf(block: SsaBlock, i: SsaIf);
	def visitSwitch(block: SsaBlock, i: SsaSwitch);
	def visitGoto(block: SsaBlock, target: SsaGoto);
	def visitReturn(block: SsaBlock, i: SsaReturn) {
		for (j < i.inputs.length) useFixed(i.inputs[j].dest, frame.conv.callerRet(j));
		emitN(ArchInstrs.ARCH_RET);
	}

	def getProjections(i: SsaApplyOp) -> Array<SsaInstr> {
		var t = i.op.sig.returnType();
		match (t.typeCon.kind) {
			V3Kind.VOID => return Ssa.NO_INSTRS;
			V3Kind.TUPLE => ; // fall through to below
			_ => return [i];
		}
		var r = Array<SsaInstr>.new(Lists.length(t.nested));
		for (l: Edge<SsaInstr> = i.useList; l != null; l = l.next) {
			if (!SsaApplyOp.?(l.src)) continue;
			var apply = SsaApplyOp.!(l.src);
			match (apply.op.opcode) {
				TupleGetElem(index) => r[index] = apply;
				_ => ;
			}
		}
		return r;
	}

	def assembleInstrs() {
		var out = if (context.shouldPrintMach(), getOutput()), indent = 1;
		if (out != null) out.puts("After register allocation: ").outln();
		for (i = first; i != null; i = i.next) {
			if (out != null) {
				indent = out.putInstr(indent, i);
				out.outt();
			}
			assemble(i.opcode(), i.operands);
		}
	}

	// Code generation.
	def assemble(opcode: int, x: Array<Operand>);
	// Rendering.
	// Override this method to add architecture-specific rendering of instructions.
	def getOutput() -> ArchInstrBuffer {
		if (out != null) return out;
		return out = ArchInstrBuffer.new(this, context.prog, regSet);
	}
}
// Helper class for rendering architecture-specific machine instructions.
class ArchInstrBuffer(codegen: SsaMachGen, prog: Program, regSet: MachRegSet) extends TerminalBuffer {
	def putBlock(indent: int, i: ArchInstr) -> int {
		while (i != null) {
			indent = putInstr(indent, i);
			i = i.next;
			if (i != null && i.opcode() == ArchInstrs.ARCH_BLOCK) break;
		}
		return indent;
	}
	def putInstrV(i: ArchInstr) {
		putInstr(2, i);
	}
	def putInstr(indent: int, i: ArchInstr) -> int {
		var a = i.operands;
		match (int.!(i.opcode())) {
			ArchInstrs.ARCH_NOP => {
				putIndent(indent + 1);
				puts("nop ");
				putOperands(a);
			}
			ArchInstrs.ARCH_ENTRY => {
				putIndent(indent);
				puts("entry ");
				putOperands(a);
			}
			ArchInstrs.ARCH_BLOCK => {
				putIndent(indent);
				puts("block ");
				putSsaBlock(Operand.Label.!(a[0]).block);
			}
			ArchInstrs.ARCH_PARMOVE => {
				putIndent(indent + 1);
				puts("parallel-move");
				var half = a.length / 2;
				for (i < half) {
					var dst = a[i], src = a[i + half];
					ln();
					putIndent(indent+4);
					putOperand(dst);
					puts(" <- ");
					putOperand(src);
				}
			}
			ArchInstrs.ARCH_RET => {
				putIndent(indent + 1);
				puts("ret ");
				putOperands(a);
			}
			ArchInstrs.ARCH_END => {
				putIndent(indent);
				puts("end");
			}
			_ => {
				indent = putArchInstr(indent + 1, i) - 1;
			}
		}
		ln();
		return indent;
	}
	// Override this method to add architecture-specific rendering of instructions.
	def putArchInstr(indent: int, i: ArchInstr) -> int {
		return putSimpleInstr(indent, i);
	}
	def putSimpleInstr(indent: int, i: ArchInstr) -> int {
		putIndent(indent);
		puts("opcode: ").putx(int.view(i.opcode())).sp();
		putOperands(i.operands);
		return indent;
	}
	def putIndent(indent: int) {
		if (indent-- > 0) tab(); // the first two indent levels are tabs
		if (indent-- > 0) tab();
		while (indent-- > 0) sp().sp(); // two spaces for each afterwards
	}
	def putSsaBlock(block: SsaBlock) {
		blue().putc('#').putd(block.uid).end();
	}
	def putSsa(i: SsaInstr) -> this {
		cyan().putc('@').putd(i.uid).end();
		if (SsaConst.?(i)) green().putc('#').putv(SsaConst.!(i).val, null).end();
	}
	def putArchWithI(name: string, x: Array<Operand>) -> this {
		var y = x[x.length - 1];
		puts(name);
		if (y.isImm()) putc('i');
		sp();
		putOperands(x);
	}
	def putNamedInstr(indent: int, name: string, x: Array<Operand>) -> int {
		putIndent(indent);
		puts(name).sp();
		putOperands(x);
		return indent;
	}
	def putOperands(x: Array<Operand>) -> this {
		for (j < x.length) {
			if (j > 0) csp();
			putOperand(x[j]);
		}
	}
	def putConstraint(constraint: int) -> this {
		if (constraint != 0) putc(':').yellow().puts(regSet.identify(constraint)).end();
	}
	def putVReg(mode: string, vreg: VReg) -> this {
		blue().puts(mode).end();
		if (vreg != null && vreg.ssa != null) putSsa(vreg.ssa);
		if (vreg != null) putc('v').putd(vreg.varNum);
	}
	def putOperand(o: Operand) -> this {
		match (o) {
			Scratch => puts("<scratch>");
			Immediate(val) => {
				blue().puts("imm").green().putc('#').putv(val, null).end();
			}
			Use(vreg, constraint) => {
				putVReg("use", vreg);
				putConstraint(constraint);
			}
			Def(vreg, constraint) => {
				putVReg("def", vreg);
				putConstraint(constraint);
			}
			Kill(livepoint, constraint) => {
				putc('k');
				if (livepoint >= 0) putd(livepoint);
				putConstraint(constraint);
			}
			Overwrite(dst, src, constraint) => {
				putVReg("ovr", dst);
				sp();
				putVReg("with", src);
				putConstraint(constraint);
			}
			Label(block, label) => {
				puts("block=");
				putSsaBlock(block);
			}
			ExSource(ex, source) => {
				if (ex != null) {
					puts("ex=");
					red().puts(ex).end();
					sp();
				}
				if (source != null) {
					puts("src=");
					purple();
					source.render(this);
					this.end();
				}
			}
		}
	}
	def putLiveness(liveness: BitMatrix, index: int) {
		put1("{livepoint=%d", index);
		for (j < liveness.numcols) {
			if (liveness[index, j]) {
				put1(" v%d", j);
			}
		}
		puts("}\n");
	}
}
// Generates machine code for all aspects of the program, including the main
// stub, fatal stubs, and SSA methods.
class MachBackend(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter) {
	def context = SsaContext.new(compiler, prog);
	// Generate all code, beginning with the entrypoint
	def genAllCode() {
		w.atEnd();
		// Generate main entrypoint
		genMainEntry();
		// Generate memory allocation stub
		genAllocStub();

		// Generate code for SSA methods
		var methods = prog.ir.methods;
		var code = mach.code;
		for (i < methods.length) {
			var m = methods[i];
			w.atEnd().align(code.addrAlign.size);
			var start = w.pos;
			var methodStart = w.endAddr();
			var addr = mach.addrOfMethod(m);
			addr.absolute = methodStart;
			context.enterMethod(m);
			genCodeFromSsa();
			addr.size = w.atEnd().pos - start;
			if (Aeneas.PRINT_BIN.get()) {
				mach.printBin(m, methodStart, w);
			} else if (Aeneas.PRINT_SIZE.get()) {
				Terminal.put2("%q: %d\n", m.renderLong, w.endAddr() - methodStart);
			}
		}

		// Generate code for stubs
		mach.stubMap.apply(genStub);
		// Generate signal handler stub
		genSignalHandlerStub();
	}
	// Generate a stub, such as a fatal stub or other shared routine
	def genStub(name: string, t: (Addr, (Addr, MachDataWriter) -> void)) {
		w.align(mach.code.addrAlign.size); // XXX: skip align for stubs?
		var addr = t.0, func = t.1;
		addr.absolute = w.endAddr();
		if (Aeneas.PRINT_MACH.val != VstMatcher.None) {
			TerminalBuffer.new()
				.put1("genStub[%s] @ ", name)
				.putv(addr, null)
				.put1(" = %x", addr.absolute)
				.outln();
		}
		if (func != null) func(addr, w);
		else genFatalStub(name, addr);
	}
	// Overridden in target-specific code generators
	def genMainEntry();
	def genAllocStub();
	def genCodeFromSsa();
	def genSignalHandlerStub();
	def genFatalStub(ex: string, addr: Addr);
	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int);
}
