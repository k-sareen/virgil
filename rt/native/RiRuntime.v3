// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// RiRuntime provides the platform-dependent runtime hooks called by the compiler
// to implement signal handling (and therefore exception handling), GC, and
// initialization of the runtime environment.
component RiRuntime {
	def SIGFPE  = 8;
	def SIGBUS  = 10;
	def SIGSEGV = 11;
	var gcInit: void -> void;
	var gcCollect: (int, Pointer, Pointer) -> Pointer;
	var userSignalHandler: (int, Pointer, Pointer) -> bool;
	var stackRedZoneStart: Pointer;
	var stackRedZoneEnd: Pointer;


	// initialize runtime system from supplied arguments and return remaining args
	def init(c: int, a: Pointer, envp: Pointer) -> Array<string> {
		var argc = c, argp = a;
		// set up stack red zone to catch stack overflow
		var t = RiOs.initStackRedZone(CiRuntime.STACK_START, CiRuntime.STACK_END);
		stackRedZoneStart = t.0;
		stackRedZoneEnd = t.1;
		// install handler for SIGFPE, SIGBUS, and SIGSEGV
		RiOs.installHandler(SIGFPE);
		RiOs.installHandler(SIGBUS);
		RiOs.installHandler(SIGSEGV);

		if (gcInit != null) gcInit();
		if (argp == Pointer.NULL) return null;

		// convert argc, argp into an Array<string> for main, ignoring first arg
		argp = argp + Pointer.SIZE;
		argc--;
		var args = Array<string>.new(argc);
		for (i < argc) {
			args[i] = toString((argp + i * Pointer.SIZE).load<Pointer>());
		}
		return args;
	}
	// handle a signal generated by the program
	def signal(signum: int, siginfo: Pointer, ucontext: Pointer) {
		// call user signal handler first, if installed
		if (userSignalHandler != null && userSignalHandler(signum, siginfo, ucontext)) return;

		var ip = RiOs.getIp(ucontext), sp = RiOs.getSp(ucontext);
		match (signum) {
			SIGFPE => return fatalException("DivideByZeroException", null, ip, sp);
			SIGBUS, SIGSEGV => {
				if (ip >= CiRuntime.EX_START && ip < CiRuntime.EX_END) {
					// IP lies in exception region, use exception entry
					var exEntry = CiRuntime.EX_TABLE + (ip - CiRuntime.EX_START);
					var frameWords = NativeStackPrinter.printExEntry(exEntry, true);
					NativeStackPrinter.printStack(RiOs.callerFrame(ip, sp, frameWords));
					return RiOs.exit(255);
				} else {
					var addr = RiOs.getAccessAddress(siginfo, ucontext);
					if (addr >= stackRedZoneStart && addr < stackRedZoneEnd) return fatalException("StackOverflow", null, ip, sp);
					if (ip == Pointer.NULL) {
						// assume an indirect call to null, generate NCE
						ip = sp.load<Pointer>() + -1; // return address is on stack
						sp = sp + Pointer.SIZE; // skip return address
					}
					// should be a source entry at this IP
					return fatalException("NullCheckException", null, ip, sp);
				}
			}
			// XXX: SIGILL -> *bad*
			// XXX: SIGQUIT -> stacktrace + quit
			// XXX: SIGKILL -> stacktrace + quit
			// XXX: SIGPROF -> take profiling sample
		}
		System.err.puts("UnexpectedSignal: ").puti(signum).ln();
		NativeStackPrinter.printStack(ip, sp);
		RiOs.exit(255);
	}
	// perform GC and allocate requested bytes or generate !HeapOverflowError
	def gc(size: int, i: Pointer, sp: Pointer) -> Pointer {
		var ip = i;
		ip = ip + -1; // adjust caller IP for gc map search
		if (gcCollect != null) {
			// call the installed collector
			return gcCollect(size, ip, sp);
		} else {
			fatalException("HeapOverflow", "no garbage collector installed", ip, sp);
			return Pointer.NULL; // unreachable
		}
	}
	// convert a null-terminated string pointer to a byte array
	private def toString(p: Pointer) -> string {
		for (e = p; true; e = e + 1) {
			if (e.load<byte>() == '\x00') {
				var len = int.!(e - p), str = Array<byte>.new(len);
				for (i < len) str[i] = (p + i).load<byte>();
				return str;
			}
		}
		return null; // unreachable
	}
	def fatalException(ex: string, msg: string, ip: Pointer, sp: Pointer) {
		System.err.putc('!').puts(ex);
		if (msg != null) System.err.puts(": ").puts(msg).ln();
		else System.err.ln();
		NativeStackPrinter.printStack(ip, sp);
		RiOs.exit(255);
	}
}
// Runtime tables are exposed by the compiler as values in a "CiRuntime" component.
// This component provides utilities to the rest of the runtime to traverse these
// tables and serves to separate them from encoding details.
component RiTables {
	def REF_SIZE	  = 4;	  // XXX: platform-dependent reference size
	def INT_SIZE	  = 4;
	def PAGE_SIZE	  = 4096; // XXX: page size from compiler
	def PAGE_SHIFT	  = '\x0c';  // 12
	def PAGE_MASK	  = 0xFFF;
	def EX_ENTRY_SIZE = 6;	  // XXX: ex entry size from compiler

	def findSource(ip: Pointer) -> Pointer {
		return exactMatch(searchTable(CiRuntime.SRC_POINTS_PAGES, CiRuntime.SRC_POINTS_TABLE, ip));
	}
	def findMethod(ip: Pointer) -> Pointer {
		var r = searchTable(CiRuntime.SRC_METHODS_PAGES, CiRuntime.SRC_METHODS_TABLE, ip);
		if (r.0 < CiRuntime.SRC_METHODS_TABLE) return Pointer.NULL;
		return r.0;
	}
	def exactMatch(p: Pointer, q: Pointer) -> Pointer {
		return if(p == q, p, Pointer.NULL);
	}
	// perform a binary search on a table, returning pointers (p, q) to adjacent entries
	// with p.ip <= ip <= q.ip || p == null && q == null
	// assumes 4-byte entries with lower #PAGE_SHIFT bits indicating the page offset
	def searchTable(pageTable: Pointer, table: Pointer, ip: Pointer) -> (Pointer, Pointer) {
		var none = (Pointer.NULL, Pointer.NULL);
		if (ip < CiRuntime.CODE_START) return none; // out of code range
		if (ip >= CiRuntime.CODE_END) return none; // out of code range

		var code_offset = ip - CiRuntime.CODE_START;
		var key_offset = code_offset & PAGE_MASK;
		var code_page = int.!(code_offset >>> PAGE_SHIFT);
		var start_p = loadPage(pageTable, code_page);
		var end_p = loadPage(pageTable, code_page + 1);
		// binary search for the entry
		while (start_p < end_p) {
			var diff = ((end_p - start_p) >> 1) & 0xFFFFFFFC;
			var mid_p = start_p + diff;
			var offset = mid_p.load<int>() & PAGE_MASK;
			if (offset < key_offset) {
				if (start_p == mid_p) return (start_p, end_p);
				else start_p = mid_p;
			} else if (offset == key_offset) {
				return (mid_p, mid_p);
			} else {
				end_p = mid_p;
			}
		}
		return (start_p + -4, end_p); // start_p == end_p
	}
	def loadPage(pageTable: Pointer, num: int) -> Pointer {
		if (Pointer.SIZE == 8) {
			return Pointer.NULL + (pageTable + num * 4).load<int>();
		} else {
			return (pageTable + num * Pointer.SIZE).load<Pointer>();
		}
	}
	def codePages() -> int {
		return int.!((CiRuntime.CODE_END - CiRuntime.CODE_START + (PAGE_SIZE - 1)) >>> PAGE_SHIFT);
	}
}
