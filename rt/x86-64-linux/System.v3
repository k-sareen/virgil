// Copyright 2021 Ben L. Titzer, Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the "System" component for Linux, using the underlying
// Linux methods.

// XXX: not thread-safe
// XXX: use on-stack storage for small IO buffers
// XXX: what about GC moving arrays during IO operations?
// XXX: merge common code with darwin/System.v3 into a common Posix implementation

// XXX: Unsound as we need to enforce that ipv4 and ipv6 are exactly 4 and 16
// u8s long respectively. One way to achieve this could be to create two more
// types, Inet4Array and Inet6Array, like so:
// class Inet4Array {
// 	def addr: Array<u8> = Array.new(4);
// }
// class Inet6Array {
// 	def addr: Array<u8> = Array.new(16);
// }
// type InetAddress {
// 	case Inet4(addr: Inet4Array);
// 	case Inet6(addr: Inet6Array);
// }
/**
 * Represents an internet address. It can be one of Inet4 for IPv4 addresses or
 * Inet6 for IPv6 addresses.
 */
type InetAddress {
	case Inet4(addr: Array<u8>);
	case Inet6(addr: Array<u8>);
}

class SocketBase {
	// IP address of socket
	def addr: InetAddress;
	// Associated file descriptor of socket
	var fd: int;
	// Local port the socket is connected to
	def localPort: int;
	// Server port the socket is connected to
	def port: int;

	new(addr, localPort, port) {
		var family: int;
		match (addr) {
			Inet4(addrV4) => family = LinuxConst.AF_INET;
			Inet6(addrV6) => family = LinuxConst.AF_INET6;
		}
		fd = System.socket(family, LinuxConst.SOCK_STREAM /* type */, 0 /* protocol */);
	}
}

class ClientSocket extends SocketBase {
	new(addr: InetAddress, localPort: int, port: int) super(addr, localPort, port) { }

	def connect() -> int {
		match (addr) {
			Inet4(addrV4) => {
				// Definition of sockaddr for IPv4:
				// struct sockaddr_in {
				//   short int          sin_family;  // Address family, AF_INET
				//   unsigned short int sin_port;    // Port number
				//   struct in_addr     sin_addr;    // Internet address
				//   unsigned char      sin_zero[8]; // Same size as struct sockaddr
				// };
				def sockAddr = Array<byte>.new(LinuxConst.SOCKADDR_V4_SIZE);
				def nboPort = u16ToNetworkByteOrder(u16.view(port));
				def nboAddr = u32ToNetworkByteOrder(
						u32.view((int.view(addrV4[0]) << 24) | (int.view(addrV4[1]) << 16)
							| (int.view(addrV4[2]) << 8) | addrV4[3])
				);
				// XXX: Disgusting hack alert! Hopefully this can be cleaned up with structs
				sockAddr[0] = byte.view(LinuxConst.AF_INET);
				sockAddr[1] = 0x00;
				sockAddr[2] = byte.view(nboPort & 0xFF);
				sockAddr[3] = byte.view((nboPort >> 8)  & 0xFF);
				sockAddr[4] = byte.view(nboAddr & 0xFF);
				sockAddr[5] = byte.view((nboAddr >> 8)  & 0xFF);
				sockAddr[6] = byte.view((nboAddr >> 16) & 0xFF);
				sockAddr[7] = byte.view((nboAddr >> 24) & 0xFF);
				return System.connect(fd, sockAddr, LinuxConst.SOCKADDR_V4_SIZE);
			}
			Inet6(addrV6) => System.error("Unimplemented", "IPv6 connections are currently unsupported!");
		}

		return -1;
	}

	def read(buf: Array<byte>) -> int {
		return System.fileReadK(fd, buf, 0, buf.length);
	}

	def write(msg: string) {
		System.fileWriteK(fd, msg, 0, msg.length);
	}

	def close() {
		System.fileClose(fd);
	}
}

// class ServerSocket extends SocketBase {
//
// }

// Network Byte Order is defined to be big-endian. These functions assume
// little-endian architecture. TODO: Have to make this a nop for big-endian architectures
def u16ToNetworkByteOrder(n: u16) -> u16 {
	return u16.view(((n & 0xFF) << 8) | ((n & 0xFF00) >> 8));
}

def u32ToNetworkByteOrder(n: u32) -> u32 {
	return u32.view(((n & 0xFF) << 24) | ((n & 0xFF00) << 8) |
		((n & 0xFF0000) >> 8) | ((n & 0xFF000000) >> 24));
}

component System {
	def ANY_V4 = InetAddress.Inet4([0, 0, 0, 0]);
	def LOCALHOST_V4 = InetAddress.Inet4([127, 0, 0, 1]);

	def ANY_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	def LOCALHOST_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);

	// @thread-local @static buffer for gettimeofday
	var timeval = Array<long>.new(2);
	// @thread-local @static buffer for fstat
	var statbuf = Array<long>.new(LinuxConst.STAT_BUF_SIZE / 8);
	// @thread-local @lazy buffer for path that don't have space for a null
	var pathbuf = Array<byte>.new(100);
	// the standard output stream
	def out = linuxFileStream(LinuxConst.STDOUT);
	// the standard input stream
	def err = linuxFileStream(LinuxConst.STDERR);
	// the method that can print a stack trace
	var printStack: (Pointer, Pointer) -> void;

	// change the permissions of a file
	def chmod(fileName: string, mode: int) {
		Linux.syscall(LinuxConst.SYS_chmod, (pathName(fileName), mode));
	}
	// open a file
	def fileOpen(fileName: string, read: bool) -> int {
		var mode = if(read, LinuxConst.O_RDONLY, LinuxConst.O_WRONLY | LinuxConst.O_TRUNC | LinuxConst.O_CREAT);
		var fd = Linux.syscall(LinuxConst.SYS_open, (pathName(fileName), mode, 420)).0;
		return if(fd >= 0, int.view(fd), -1);
	}
	// close a file
	def fileClose(fd: int) {
		Linux.syscall(LinuxConst.SYS_close, fd);
	}
	// read a single byte from a file
	def fileRead(fd: int) -> int {
		var r = Linux.syscall(LinuxConst.SYS_read, (fd, Pointer.atContents(out.iobuf), 1)).0;
		return if(r == 1, out.iobuf[0], -1);
	}
	// write some bytes to the file
	def fileWriteK(fd: int, data: Array<byte>, offset: int, len: int) {
		boundsCheck(data, offset, len);
		var buf = Pointer.atContents(data) + offset;
		Linux.syscall(LinuxConst.SYS_write, (fd, buf, len));
	}
	// read some bytes from the file
	def fileReadK(fd: int, data: Array<byte>, offset: int, len: int) -> int {
		boundsCheck(data, offset, len);
		var buf = Pointer.atContents(data) + offset;
		var r = Linux.syscall(LinuxConst.SYS_read, (fd, buf, len)).0;
		return if(r > 0, int.view(r));
	}
	// XXX: factor out bounds check to common code?
	private def BCE = "BoundsCheckException";
	private def EMPTY = "";
	private def boundsCheck<T>(array: Array<T>, start: int, len: int) {
		if (start < 0) System.error(BCE, EMPTY);
		if (start > array.length) System.error(BCE, EMPTY);
		var end = long.view(start) + long.view(len);
		if (u64.view(end) > u32.view(array.length)) System.error(BCE, EMPTY);
	}
	// calculate bytes remaining to be read from file
	def fileLeft(fd: int) -> int {
		// XXX: is there a cheaper way to tell the number of available bytes?
		var offset = Linux.syscall(LinuxConst.SYS_lseek, (fd, 0, LinuxConst.SEEK_CUR)).0;
		var end = Linux.syscall(LinuxConst.SYS_lseek, (fd, 0, LinuxConst.SEEK_END)).0;
		Linux.syscall(LinuxConst.SYS_lseek, (fd, offset, LinuxConst.SEEK_SET));
		return int.view(end - offset);
	}
	// load a file into a byte array
	def fileLoad(fileName: string) -> Array<byte> {
		var path = pathName(fileName);
		if (Linux.syscall(LinuxConst.SYS_stat, (path, Pointer.atContents(statbuf))).0 < 0) return null;
		var fd = Linux.syscall(LinuxConst.SYS_open, (path, LinuxConst.O_RDONLY, 0)).0;
		if (fd < 0) return null;
		var buf = Array<byte>.new(int.!(statbuf[LinuxConst.STAT_WOFF_ST_SIZE]));
		if (Linux.syscall(LinuxConst.SYS_read, (fd, Pointer.atContents(buf), buf.length)).0 < 0) return null;
		Linux.syscall(LinuxConst.SYS_close, fd);
		return buf;
	}
	def socket(family: int, socketType: int, protocol: int) -> int {
		// (return value, errno)
		def ret = Linux.syscall(LinuxConst.SYS_socket, (family, socketType, protocol));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def connect(sockfd: int, sockAddr: Array<byte>, addrLen: int) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_connect, (sockfd, Pointer.atContents(sockAddr), addrLen));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def bind(sockfd: int, sockAddr: Array<byte>, addrLen: int) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_bind, (sockfd, Pointer.atContents(sockAddr), addrLen));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	// print a character to standard out
	def putc(ch: byte) {
		out.putc(ch);
	}
	// print an integer (in decimal) to standard out
	def puti(i: int) {
		out.puti(i);
	}
	// print a string (as bytes) to standard out
	def puts(str: string) {
		out.puts(str);
	}
	// prints a newline character to standard out
	def ln() {
		out.ln();
	}
	// output an error, stacktrace, and exit
	def error(ex: string, msg: string) {
		err.putc('!').puts(ex).puts(": ").puts(msg).putc('\n');
		if (printStack != null) printStack(CiRuntime.callerIp() + -1, CiRuntime.callerSp());
		Linux.syscall(LinuxConst.SYS_exit, 254);
	}
	// get ticks in milliseconds
	def ticksMs() -> int {
		Linux.syscall(LinuxConst.SYS_gettimeofday, (Pointer.atContents(timeval), Pointer.NULL));
		return int.view(timeval[0] * 1000 + timeval[1] / 1000);
	}
	// get ticks in microseconds
	def ticksUs() -> int {
		Linux.syscall(LinuxConst.SYS_gettimeofday, (Pointer.atContents(timeval), Pointer.NULL));
		return int.view(timeval[0] * 1000000 + timeval[1]);
	}
	// get ticks in nanoseconds
	def ticksNs() -> int {
		Linux.syscall(LinuxConst.SYS_gettimeofday, (Pointer.atContents(timeval), Pointer.NULL));
		return int.view(timeval[1] * 1000);
	}
	// get a zero-terminated pathname, allocating if necessary
	private def pathName(fileName: string) -> Pointer {
		if ((fileName.length & 3) == 0) {
			// no extra space on the end of the array for the null byte
			if (pathbuf.length <= fileName.length) pathbuf = Array.new(fileName.length + 5);
			for (i < fileName.length) pathbuf[i] = fileName[i];
			pathbuf[fileName.length] = '\x00';
			return Pointer.atContents(pathbuf);
		}
		return Pointer.atContents(fileName);
	}
}
def linuxWrite(fd: int, buf: Pointer, len: int) -> int {
	var t = Linux.syscall(LinuxConst.SYS_write, (fd, buf, len));
	return int.view(t.0);
}
def linuxFileStream(fd: int) -> NativeFileStream {
	return NativeFileStream.new(linuxWrite, fd);
}
