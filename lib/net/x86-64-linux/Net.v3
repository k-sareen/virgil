// Copyright 2022 Kunal Sareen. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the "Net" component for Linux, using underlying Linux
// syscalls and methods.

// XXX: Unsound as we need to enforce that ipv4 and ipv6 are exactly 4 and 16
// u8s long respectively. One way to achieve this could be to create two more
// types, Inet4Array and Inet6Array, like so:
// class Inet4Array {
// 	def addr: Array<u8> = Array.new(4);
// }
// class Inet6Array {
// 	def addr: Array<u8> = Array.new(16);
// }
// type InetAddress {
// 	case Inet4(addr: Inet4Array);
// 	case Inet6(addr: Inet6Array);
// }
/**
 * Represents an internet address. It can be one of Inet4 for IPv4 addresses or
 * Inet6 for IPv6 addresses.
 */
type InetAddress {
	case Inet4(addr: Array<u8>);
	case Inet6(addr: Array<u8>);
}

class IntPointer(x: int) { }

class SocketBase {
	// IP address of socket
	def addr: InetAddress;
	// Associated file descriptor of socket
	def var fd: int;
	// Server port the socket is connected to
	def port: int;

	new(addr, port) {
		var family: int;
		match (addr) {
			Inet4(addrV4) => family = LinuxConst.AF_INET;
			Inet6(addrV6) => family = LinuxConst.AF_INET6;
		}
		fd = Net.socket(family, LinuxConst.SOCK_STREAM /* type */, 0 /* protocol */);
	}

	def read(buf: Array<byte>) -> int {
		return System.fileReadK(fd, buf, 0, buf.length);
	}

	def write(msg: string) {
		System.fileWriteK(fd, msg, 0, msg.length);
	}

	def close() {
		System.fileClose(fd);
	}
}

class ClientSocket extends SocketBase {
	// Local port the socket is connected to
	private var localPort: int;
	// Associated sockaddr_in structure. Is instantiated in connect()
	private var sockAddr: Array<byte>;

	new(addr: InetAddress, port: int) super(addr, port) { }

	def connect() -> int {
		match (addr) {
			Inet4(addrV4) => {
				// Definition of sockaddr for IPv4:
				// struct sockaddr_in {
				//   short int          sin_family;  // Address family, AF_INET
				//   unsigned short int sin_port;    // Port number
				//   struct in_addr     sin_addr;    // Internet address
				//   unsigned char      sin_zero[8]; // Same size as struct sockaddr
				// };
				def sockAddrBldr = DataWriter.new();
				sockAddrBldr.acquire(LinuxConst.SOCKADDR_V4_SIZE);
				def addrInt = (int.view(addrV4[0]) << 24) | (int.view(addrV4[1]) << 16)
							| (int.view(addrV4[2]) << 8) | addrV4[3];
				// sin_family
				sockAddrBldr.put_b16(LinuxConst.AF_INET);
				// sin_port
				sockAddrBldr.put_b16be(int.view(port));
				// sin_addr
				sockAddrBldr.put_b32be(addrInt);
				// sin_zero
				sockAddrBldr.zeroN(8);

				sockAddr = sockAddrBldr.extract();

				// Connect socket
				def ret = Net.connect(fd, sockAddr);
				def retSockAddr = Array<byte>.new(LinuxConst.SOCKADDR_V4_SIZE);
				def sockNameRet = Net.getsockname(fd, retSockAddr);
				if (ret == -1 || sockNameRet == -1) {
					return -1;
				}
				localPort = (int.view(retSockAddr[2]) << 8) | int.view(retSockAddr[3]);
				return ret;
			}
			Inet6(addrV6) => System.error("Unimplemented", "IPv6 connections are currently unsupported!");
		}

		return -1;
	}
}

// class ServerSocket extends SocketBase {
//	// Local port the socket is connected to
//	private localPort: int;
//
// 	new(addr: InetAddr, port: int) super(addr, port) { }
//
// }

component Net {
	def ANY_V4 = InetAddress.Inet4([0, 0, 0, 0]);
	def LOCALHOST_V4 = InetAddress.Inet4([127, 0, 0, 1]);

	def ANY_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	def LOCALHOST_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);

	def socket(family: int, socketType: int, protocol: int) -> int {
		// (return value, errno)
		def ret = Linux.syscall(LinuxConst.SYS_socket, (family, socketType, protocol));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def connect(sockfd: int, sockAddr: Array<byte>) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_connect, (sockfd, Pointer.atContents(sockAddr), sockAddr.length));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def bind(sockfd: int, sockAddr: Array<byte>) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_bind, (sockfd, Pointer.atContents(sockAddr), sockAddr.length));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def getsockname(sockfd: int, sockAddr: Array<byte>) -> int {
		var ptr = IntPointer.new(sockAddr.length);
		def ret = Linux.syscall(LinuxConst.SYS_getsockname, (sockfd, Pointer.atContents(sockAddr), Pointer.atField(ptr.x)));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
}
