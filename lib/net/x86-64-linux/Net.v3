// Copyright 2022 Kunal Sareen. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the "Net" component for Linux, using underlying Linux
// syscalls and methods.

// XXX: Unsound as we need to enforce that ipv4 and ipv6 are exactly 4 and 16
// u8s long respectively. One way to achieve this could be to create two more
// types, Inet4Array and Inet6Array, like so:
// class Inet4Array {
// 	def addr: Array<u8> = Array.new(4);
// }
// class Inet6Array {
// 	def addr: Array<u8> = Array.new(16);
// }
// type InetAddress {
// 	case Inet4(addr: Inet4Array);
// 	case Inet6(addr: Inet6Array);
// }
/**
 * Represents an internet address. It can be one of Inet4 for IPv4 addresses or
 * Inet6 for IPv6 addresses.
 */
type InetAddress {
	case Inet4(addr: Array<u8>);
	case Inet6(addr: Array<u8>);

	def render(buf: StringBuilder) -> StringBuilder {
		match (this) {
			Inet4(addrV4) => {
				buf.put3("%d.%d.%d.", addrV4[0], addrV4[1], addrV4[2]);
				buf.put1("%d", addrV4[3]);
			}
			Inet6(addrV6) => {
				def len = addrV6.length;
				var zeroStart = -1, zeroEnd = -1;
				// Find the start and end of the longest chain of zeroes
				for (i = 0; i < len; i += 2) {
					var j = i;
					while (j < len) {
						if (addrV6[j] == 0 && addrV6[j + 1] == 0) {
							j += 2;
						} else {
							break;
						}
					}

					if (j > i && (j - i) > zeroEnd - zeroStart) {
						zeroStart = i;
						zeroEnd = j;
						i = j;
					}
				}

				// If only atmost 2 bytes are 0, then we just display them
				if (zeroEnd - zeroStart <= 2) {
					zeroStart = -1;
					zeroEnd = -1;
				}

				for (i = 0; i < len; i += 2) {
					if (i == zeroStart) {
						buf.puts("::");
						i = zeroEnd;
						if (i >= len) {
							break;
						}
					} else if (i > 0) {
						buf.puts(":");
					}
					buf.put1("%x", (int.view(addrV6[i]) << 8) | addrV6[i + 1]);
				}
			}
		}
		return buf;
	}
}

/**
 * Pointer to an int used for interfacing with the kernel
 */
class IntPointer(x: int) { }

/**
 * Convert a Socket {socket} to its C-struct representation. The return value
 * for IPv4 should match the struct sockaddr_in type, while the return value
 * for IPv6 should match the struct sockaddr_in6 type. Note that the port and
 * IP address need to written in network-byte order, i.e. in big-endian.
 *
 * Returns the C-struct representation of {socket}.
 */
def socketToSockAddr(socket: Socket, server: bool) -> Array<byte> {
	match (socket.addr) {
		Inet4(addrV4) => {
			// Definition of sockaddr for IPv4:
			// struct sockaddr_in {
			//   short int          sin_family;  // Address family, AF_INET
			//   unsigned short int sin_port;    // Port number
			//   struct in_addr     sin_addr;    // Internet address
			//   unsigned char      sin_zero[8]; // Same size as struct sockaddr
			// };
			def sockAddrBldr = DataWriter.new();
			def port = if(server, socket.localPort, socket.port);
			sockAddrBldr.acquire(LinuxConst.SOCKADDR_V4_SIZE);
			// sin_family
			sockAddrBldr.put_b16(LinuxConst.AF_INET);
			// sin_port
			sockAddrBldr.put_b16be(int.view(port));
			// sin_addr
			sockAddrBldr.putb(addrV4[0]);
			sockAddrBldr.putb(addrV4[1]);
			sockAddrBldr.putb(addrV4[2]);
			sockAddrBldr.putb(addrV4[3]);
			// sin_zero
			sockAddrBldr.zeroN(8);
			return sockAddrBldr.extract();
		}
		Inet6(addrV6) => {
			System.error("Unimplemented", "IPv6 connections are currently unsupported!");
			return null;
		}
	}
}

/**
 * An abstraction over a network socket that allows for sending and receiving
 * messages.
 */
class Socket {
	// IP address of socket
	def addr: InetAddress;
	// Associated file descriptor of socket
	def var fd: int;
	// Local port the socket is connected to
	def var localPort: int;
	// Server port the socket is connected to
	def var port: int;

	new(addr, localPort, port, sockfd: int, createSocket: bool) {
		if (createSocket) {
			var family: int;
			match (addr) {
				Inet4(addrV4) => family = LinuxConst.AF_INET;
				Inet6(addrV6) => family = LinuxConst.AF_INET6;
			}
			fd = Net.socket(family, LinuxConst.SOCK_STREAM /* type */, 0 /* protocol */);
		} else {
			fd = sockfd;
		}
	}

	def setLocalPort(local: int) {
		localPort = local;
	}

	/**
	 * Read a message into buffer {buf} from the socket. Return how many bytes
	 * were read into the buffer.
	 */
	def read(buf: Array<byte>) -> int {
		return System.fileReadK(fd, buf, 0, buf.length);
	}

	/**
	 * Write a message {msg} into the socket.
	 */
	def write(msg: string) {
		System.fileWriteK(fd, msg, 0, msg.length);
	}

	/**
	 * Close the socket.
	 */
	def close() {
		System.fileClose(fd);
	}
}

/**
 * A socket that connects to remote host.
 */
class ClientSocket extends Socket {
	// Associated sockaddr structure. Is instantiated in connect()
	private var sockAddr: Array<byte>;

	new(addr: InetAddress, port: int) super(addr, -1 /* localPort */, port, -1 /* fd */, true) { }

	/**
	 * Connect socket to remote host with IP address {addr} on {port}. Returns -1
	 * if an error has occurred and 0 if everything is correctly functioning.
	 */
	def connect() -> int {
		sockAddr = socketToSockAddr(this, false);
		match (addr) {
			Inet4(addrV4) => {
				// Connect socket
				def ret = Net.connect(fd, sockAddr);
				def retSockAddr = Array<byte>.new(LinuxConst.SOCKADDR_V4_SIZE);
				def sockNameRet = Net.getsockname(fd, retSockAddr);
				if (ret == -1 || sockNameRet == -1) {
					return -1;
				}
				// XXX: Why can't we set `def var` fields from a subclass?
				setLocalPort((int.view(retSockAddr[2]) << 8) | int.view(retSockAddr[3]));
				return ret;
			}
			Inet6(addrV6) => System.error("Unimplemented", "IPv6 connections are currently unsupported!");
		}

		return -1;
	}
}

/**
 * A socket that accepts connections from incoming peers.
 */
class ServerSocket extends Socket {
	// Associated sockaddr structure. Is instantiated in bind()
	private var sockAddr: Array<byte>;

	new(addr: InetAddress, localPort: int) super(addr, localPort, -1 /* port */, -1 /* fd */, true) { }

	/**
	 * Bind socket to IP address {addr} on {localPort}. Returns -1 if an error
	 * has occurred and 0 if everything is correctly functioning.
	 */
	def bind() -> int {
		sockAddr = socketToSockAddr(this, true);
		match (addr) {
			Inet4(addrV4) => {
				// Bind socket to localPort
				return Net.bind(fd, sockAddr);
			}
			Inet6(addrV6) => System.error("Unimplemented", "IPv6 connections are currently unsupported!");
		}

		return -1;
	}

	/**
	 * Start listening on {addr}:{localPort} for incoming connections. Returns -1
	 * if an error has occurred and 0 if everything is correctly functioning.
	 */
	def listen() -> int {
		return Net.listen(fd, 10 /* backlog */);
	}

	/**
	 * Accept an incoming connection {addr}:{localPort} for incoming connections.
	 * Returns null if an error has occurred and a {Socket} for the new incoming
	 * connection if everything is correctly functioning.
	 */
	def accept() -> Socket {
		var retSockAddr = Array<byte>.new(LinuxConst.SOCKADDR_STORAGE_SIZE);
		var retSock = Net.accept(fd, retSockAddr);
		def retSockAddrSize = retSock.1.x;
		match (retSockAddrSize) {
			LinuxConst.SOCKADDR_V4_SIZE => {
				retSockAddr = Arrays.range(retSockAddr, 0, retSockAddrSize);
				def retAddr = InetAddress.Inet4(Arrays.range(retSockAddr, 4, 8));
				def retPort = (int.view(retSockAddr[2]) << 8) | int.view(retSockAddr[3]);
				return Socket.new(retAddr, localPort, retPort, retSock.0, false);
			}
			LinuxConst.SOCKADDR_V6_SIZE => {
				System.error("Unimplemented", "IPv6 connections are currently unsupported!");
			}
			LinuxConst.SOCKADDR_UNIX_SIZE => {
				System.error("Unimplemented", "UNIX connections are currently unsupported!");
			}
			_ => {
				System.error("Error", "Unexpected size for returned sockaddr!");
			}
		}

		return null;
	}
}

component Net {
	def ANY_V4 = InetAddress.Inet4([0, 0, 0, 0]);
	def LOCALHOST_V4 = InetAddress.Inet4([127, 0, 0, 1]);

	def ANY_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	def LOCALHOST_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);

	/**
	 * Create a new socket with {family}, {socketType}, {protocol}. Returns
	 * the new fd for the created socket and -1 if an error occurred.
	 *
	 * See: man 2 socket
	 */
	def socket(family: int, socketType: int, protocol: int) -> int {
		// (return value, errno)
		def ret = Linux.syscall(LinuxConst.SYS_socket, (family, socketType, protocol));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}

	/**
	 * Connect to socket with {sockfd} and {sockAddr} struct. Returns 0 if
	 * the connection succeeds and -1 if an error occurred.
	 *
	 * See: man 2 connect
	 */
	def connect(sockfd: int, sockAddr: Array<byte>) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_connect, (sockfd, Pointer.atContents(sockAddr), sockAddr.length));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}

	/**
	 * Accept a new connection on socket {sockfd}. Write metadata for the
	 * new connection in the {sockAddr} struct. Returns a tuple of the new
	 * fd for the new socket and the length of the written metadata.
	 * Returns -1 if an error occurred.
	 *
	 * See: man 2 accept
	 */
	def accept(sockfd: int, sockAddr: Array<byte>) -> (int, IntPointer) {
		var ptr = IntPointer.new(sockAddr.length);
		def ret = Linux.syscall(LinuxConst.SYS_accept, (sockfd, Pointer.atContents(sockAddr), Pointer.atField(ptr.x)));
		return (if(ret.0 >= 0, int.view(ret.0), -1), ptr);
	}

	/**
	 * Bind a socket {sockfd} to the IP address and port specified in the
	 * {sockAddr} struct. Returns 0 if the binding succeeds and -1 if an
	 * error occurred.
	 *
	 * See: man 2 bind
	 */
	def bind(sockfd: int, sockAddr: Array<byte>) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_bind, (sockfd, Pointer.atContents(sockAddr), sockAddr.length));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}

	/**
	 * Start listening for incoming connection on socket {sockfd}.
	 * {backlog} specifies the length of the message queue. Returns 0 if
	 * the binding succeeds and -1 if an error occurred.
	 *
	 * See: man 2 listen
	 */
	def listen(sockfd: int, backlog: int) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_listen, (sockfd, backlog));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}

	/**
	 * Write the address and port to the {sockAddr} struct the socket
	 * {sockfd} is currently bound to. This is used to query the
	 * {localPort} for ClientSockets. Returns 0 if the query succeeds and
	 * -1 if an error occurred.
	 *
	 * See: man 2 getsockname
	 */
	def getsockname(sockfd: int, sockAddr: Array<byte>) -> int {
		var ptr = IntPointer.new(sockAddr.length);
		def ret = Linux.syscall(LinuxConst.SYS_getsockname, (sockfd, Pointer.atContents(sockAddr), Pointer.atField(ptr.x)));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
}
