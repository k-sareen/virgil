// Copyright 2022 Kunal Sareen. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the "Net" component for Linux, using underlying Linux
// syscalls and methods.

// XXX: Unsound as we need to enforce that ipv4 and ipv6 are exactly 4 and 16
// u8s long respectively. One way to achieve this could be to create two more
// types, Inet4Array and Inet6Array, like so:
// class Inet4Array {
// 	def addr: Array<u8> = Array.new(4);
// }
// class Inet6Array {
// 	def addr: Array<u8> = Array.new(16);
// }
// type InetAddress {
// 	case Inet4(addr: Inet4Array);
// 	case Inet6(addr: Inet6Array);
// }
/**
 * Represents an internet address. It can be one of Inet4 for IPv4 addresses or
 * Inet6 for IPv6 addresses.
 */
type InetAddress {
	case Inet4(addr: Array<u8>);
	case Inet6(addr: Array<u8>);

	def render(buf: StringBuilder) -> StringBuilder {
		match (this) {
			Inet4(addrV4) => {
				buf.put3("%d.%d.%d.", addrV4[0], addrV4[1], addrV4[2]);
				buf.put1("%d", addrV4[3]);
			}
			Inet6(addrV6) => {
				def len = addrV6.length;
				var zeroStart = -1, zeroEnd = -1;
				// Find the start and end of the longest chain of zeroes
				for (i = 0; i < len; i += 2) {
					var j = i;
					while (j < len) {
						if (addrV6[j] == 0 && addrV6[j + 1] == 0) {
							j += 2;
						} else {
							break;
						}
					}

					if (j > i && (j - i) > zeroEnd - zeroStart) {
						zeroStart = i;
						zeroEnd = j;
						i = j;
					}
				}

				// If only atmost 2 bytes are 0, then we just display them
				if (zeroEnd - zeroStart <= 2) {
					zeroStart = -1;
					zeroEnd = -1;
				}

				for (i = 0; i < len; i += 2) {
					if (i == zeroStart) {
						buf.puts("::");
						i = zeroEnd;
						if (i >= len) {
							break;
						}
					} else if (i > 0) {
						buf.puts(":");
					}
					buf.put1("%x", (int.view(addrV6[i]) << 8) | addrV6[i + 1]);
				}
			}
		}
		return buf;
	}
}

class IntPointer(x: int) { }

def socketToSockAddr(socket: SocketBase, server: bool) -> Array<byte> {
	match (socket.addr) {
		Inet4(addrV4) => {
			// Definition of sockaddr for IPv4:
			// struct sockaddr_in {
			//   short int          sin_family;  // Address family, AF_INET
			//   unsigned short int sin_port;    // Port number
			//   struct in_addr     sin_addr;    // Internet address
			//   unsigned char      sin_zero[8]; // Same size as struct sockaddr
			// };
			def sockAddrBldr = DataWriter.new();
			def port = if(server, socket.localPort, socket.port);
			sockAddrBldr.acquire(LinuxConst.SOCKADDR_V4_SIZE);
			def addrInt = (int.view(addrV4[0]) << 24)
				| (int.view(addrV4[1]) << 16)
				| (int.view(addrV4[2]) << 8)
				| addrV4[3];
			// sin_family
			sockAddrBldr.put_b16(LinuxConst.AF_INET);
			// sin_port
			sockAddrBldr.put_b16be(int.view(port));
			// sin_addr
			sockAddrBldr.put_b32be(addrInt);
			// sin_zero
			sockAddrBldr.zeroN(8);
			return sockAddrBldr.extract();
		}
		Inet6(addrV6) => {
			System.error("Unimplemented", "IPv6 connections are currently unsupported!");
			return null;
		}
	}
}

class SocketBase {
	// IP address of socket
	def addr: InetAddress;
	// Associated file descriptor of socket
	def var fd: int;
	// Local port the socket is connected to
	def var localPort: int;
	// Server port the socket is connected to
	def var port: int;

	new(addr, localPort, port, sockfd: int, createSocket: bool) {
		if (createSocket) {
			var family: int;
			match (addr) {
				Inet4(addrV4) => family = LinuxConst.AF_INET;
				Inet6(addrV6) => family = LinuxConst.AF_INET6;
			}
			fd = Net.socket(family, LinuxConst.SOCK_STREAM /* type */, 0 /* protocol */);
		} else {
			fd = sockfd;
		}
	}

	def setLocalPort(local: int) {
		localPort = local;
	}

	def read(buf: Array<byte>) -> int {
		return System.fileReadK(fd, buf, 0, buf.length);
	}

	def write(msg: string) {
		System.fileWriteK(fd, msg, 0, msg.length);
	}

	def close() {
		System.fileClose(fd);
	}
}

class ClientSocket extends SocketBase {
	// Associated sockaddr structure. Is instantiated in connect()
	private var sockAddr: Array<byte>;

	new(addr: InetAddress, port: int) super(addr, -1 /* localPort */, port, -1 /* fd */, true) { }

	def connect() -> int {
		sockAddr = socketToSockAddr(this, false);
		match (addr) {
			Inet4(addrV4) => {
				// Connect socket
				def ret = Net.connect(fd, sockAddr);
				def retSockAddr = Array<byte>.new(LinuxConst.SOCKADDR_V4_SIZE);
				def sockNameRet = Net.getsockname(fd, retSockAddr);
				if (ret == -1 || sockNameRet == -1) {
					return -1;
				}
				// XXX: Why can't we set `def var` fields from a subclass?
				setLocalPort((int.view(retSockAddr[2]) << 8) | int.view(retSockAddr[3]));
				return ret;
			}
			Inet6(addrV6) => System.error("Unimplemented", "IPv6 connections are currently unsupported!");
		}

		return -1;
	}
}

class ServerSocket extends SocketBase {
	// Associated sockaddr structure. Is instantiated in bind()
	private var sockAddr: Array<byte>;

	new(addr: InetAddress, localPort: int) super(addr, localPort, -1 /* port */, -1 /* fd */, true) { }

	def bind() -> int {
		sockAddr = socketToSockAddr(this, true);
		match (addr) {
			Inet4(addrV4) => {
				// Bind socket to localPort
				return Net.bind(fd, sockAddr);
			}
			Inet6(addrV6) => System.error("Unimplemented", "IPv6 connections are currently unsupported!");
		}

		return -1;
	}

	def listen() -> int {
		return Net.listen(fd, 10 /* backlog */);
	}

	def accept() -> SocketBase {
		var retSockAddr = Array<byte>.new(LinuxConst.SOCKADDR_STORAGE_SIZE);
		var retSock = Net.accept(fd, retSockAddr);
		def retSockAddrSize = retSock.1.x;
		match (retSockAddrSize) {
			LinuxConst.SOCKADDR_V4_SIZE => {
				// XXX: This is all IPv4 specific
				retSockAddr = Arrays.range(retSockAddr, 0, retSockAddrSize);
				def retAddr = InetAddress.Inet4(Arrays.range(retSockAddr, 4, 8));
				def retPort = (int.view(retSockAddr[2]) << 8) | int.view(retSockAddr[3]);
				return SocketBase.new(retAddr, localPort, retPort, retSock.0, false);
			}
			LinuxConst.SOCKADDR_V6_SIZE => {
				System.error("Unimplemented", "IPv6 connections are currently unsupported!");
			}
			LinuxConst.SOCKADDR_UNIX_SIZE => {
				System.error("Unimplemented", "UNIX connections are currently unsupported!");
			}
			_ => {
				System.error("Error", "Unexpected size for returned sockaddr!");
			}
		}

		return null;
	}
}

component Net {
	def ANY_V4 = InetAddress.Inet4([0, 0, 0, 0]);
	def LOCALHOST_V4 = InetAddress.Inet4([127, 0, 0, 1]);

	def ANY_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	def LOCALHOST_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);

	def socket(family: int, socketType: int, protocol: int) -> int {
		// (return value, errno)
		def ret = Linux.syscall(LinuxConst.SYS_socket, (family, socketType, protocol));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def connect(sockfd: int, sockAddr: Array<byte>) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_connect, (sockfd, Pointer.atContents(sockAddr), sockAddr.length));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def accept(sockfd: int, sockAddr: Array<byte>) -> (int, IntPointer) {
		var ptr = IntPointer.new(sockAddr.length);
		def ret = Linux.syscall(LinuxConst.SYS_accept, (sockfd, Pointer.atContents(sockAddr), Pointer.atField(ptr.x)));
		return (if(ret.0 >= 0, int.view(ret.0), -1), ptr);
	}
	def bind(sockfd: int, sockAddr: Array<byte>) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_bind, (sockfd, Pointer.atContents(sockAddr), sockAddr.length));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def listen(sockfd: int, backlog: int) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_listen, (sockfd, backlog));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def getsockname(sockfd: int, sockAddr: Array<byte>) -> int {
		var ptr = IntPointer.new(sockAddr.length);
		def ret = Linux.syscall(LinuxConst.SYS_getsockname, (sockfd, Pointer.atContents(sockAddr), Pointer.atField(ptr.x)));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
}
