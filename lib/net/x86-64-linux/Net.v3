// XXX: Unsound as we need to enforce that ipv4 and ipv6 are exactly 4 and 16
// u8s long respectively. One way to achieve this could be to create two more
// types, Inet4Array and Inet6Array, like so:
// class Inet4Array {
// 	def addr: Array<u8> = Array.new(4);
// }
// class Inet6Array {
// 	def addr: Array<u8> = Array.new(16);
// }
// type InetAddress {
// 	case Inet4(addr: Inet4Array);
// 	case Inet6(addr: Inet6Array);
// }
/**
 * Represents an internet address. It can be one of Inet4 for IPv4 addresses or
 * Inet6 for IPv6 addresses.
 */
type InetAddress {
	case Inet4(addr: Array<u8>);
	case Inet6(addr: Array<u8>);
}

class SocketBase {
	// IP address of socket
	def addr: InetAddress;
	// Associated file descriptor of socket
	def var fd: int;
	// Local port the socket is connected to
	def localPort: int;
	// Server port the socket is connected to
	def port: int;

	new(addr, localPort, port) {
		var family: int;
		match (addr) {
			Inet4(addrV4) => family = LinuxConst.AF_INET;
			Inet6(addrV6) => family = LinuxConst.AF_INET6;
		}
		fd = Net.socket(family, LinuxConst.SOCK_STREAM /* type */, 0 /* protocol */);
	}
}

class ClientSocket extends SocketBase {
	new(addr: InetAddress, localPort: int, port: int) super(addr, localPort, port) { }

	def connect() -> int {
		match (addr) {
			Inet4(addrV4) => {
				// Definition of sockaddr for IPv4:
				// struct sockaddr_in {
				//   short int          sin_family;  // Address family, AF_INET
				//   unsigned short int sin_port;    // Port number
				//   struct in_addr     sin_addr;    // Internet address
				//   unsigned char      sin_zero[8]; // Same size as struct sockaddr
				// };
				def sockAddr = DataWriter.new();
				sockAddr.acquire(LinuxConst.SOCKADDR_V4_SIZE);
				def addrInt = (int.view(addrV4[0]) << 24) | (int.view(addrV4[1]) << 16)
							| (int.view(addrV4[2]) << 8) | addrV4[3];
				// sin_family
				sockAddr.put_b16(LinuxConst.AF_INET);
				// sin_port
				sockAddr.put_b16be(int.view(port));
				// sin_addr
				sockAddr.put_b32be(addrInt);
				// sin_zero
				sockAddr.zeroN(8);
				return Net.connect(fd, sockAddr.extract(), LinuxConst.SOCKADDR_V4_SIZE);
			}
			Inet6(addrV6) => System.error("Unimplemented", "IPv6 connections are currently unsupported!");
		}

		return -1;
	}

	def read(buf: Array<byte>) -> int {
		return System.fileReadK(fd, buf, 0, buf.length);
	}

	def write(msg: string) {
		System.fileWriteK(fd, msg, 0, msg.length);
	}

	def close() {
		System.fileClose(fd);
	}
}

// class ServerSocket extends SocketBase {
//
// }

component Net {
	def ANY_V4 = InetAddress.Inet4([0, 0, 0, 0]);
	def LOCALHOST_V4 = InetAddress.Inet4([127, 0, 0, 1]);

	def ANY_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	def LOCALHOST_V6 = InetAddress.Inet6([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);

	def socket(family: int, socketType: int, protocol: int) -> int {
		// (return value, errno)
		def ret = Linux.syscall(LinuxConst.SYS_socket, (family, socketType, protocol));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def connect(sockfd: int, sockAddr: Array<byte>, addrLen: int) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_connect, (sockfd, Pointer.atContents(sockAddr), addrLen));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
	def bind(sockfd: int, sockAddr: Array<byte>, addrLen: int) -> int {
		def ret = Linux.syscall(LinuxConst.SYS_bind, (sockfd, Pointer.atContents(sockAddr), addrLen));
		return if(ret.0 >= 0, int.view(ret.0), -1);
	}
}
